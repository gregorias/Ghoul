\chapter{Ghoul implementation}
In this chapter we present Ghoul's implementation.
We focus on general techniques used in Ghoul's development to produce high-quality code.
In section \ref{sec:build} we present build tools used and an example session with Ghoul.
In section \ref{sec:implementation} we show, as an example of our design principles, the interface of \texttt{KademliaRouting} - the core class in the protocol.

Ghoul is an open-source project.
An up-to-date Ghoul's code is available for public audience at \url{https://github.com/gregorias/ghoul}.

\section{Build system and running}
\label{sec:build}

\subsection{Gradle}
Currently Ghoul's code contains around 8000 lines of code in 126 Java files (excluding dfuntest's project).
To maintain this amount of code we use Gradle \footnote{\url{https://gradle.org/}} build automation framework.
In Gradle, developers write configuration scripts called \texttt{build.gradle} in which they define code's properties --- e.g. name of the project, project's dependencies; and build tasks.
Those configuration scripts are written in a functional, dynamically typed language.
This allows for expressive and succinct definition of build tasks, which is an
advantage over more traditional build framework - Maven \footnote{\url{https://maven.apache.org/}}.
Next, Gradle performs, using provided information, typical task in Java's build ecosystem: compilation, packaging, dependency resolution, unit testing, software validation etc.
Gradle allows developers to download and build Ghoul in two steps: Download the software from GitHub and run build task in Gradle (shown in figure \ref{fig:ghoul_build_process})

\begin{figure}[tb]
\begin{verbatim}
> git clone https://github.com/gregorias/ghoul
...

> cd ghoul

> ./gradlew build
:assemble UP-TO-DATE
:check UP-TO-DATE
:build UP-TO-DATE
:ghoul-core:compileJava
:ghoul-core:processResources UP-TO-DATE
:ghoul-core:classes
:ghoul-core:jar
:ghoul-core:javadoc
...
:ghoul-dfuntest:pmdMain
:ghoul-dfuntest:pmdTest UP-TO-DATE
:ghoul-dfuntest:test UP-TO-DATE
:ghoul-dfuntest:check
:ghoul-dfuntest:build

BUILD SUCCESSFUL

Total time: 31.617 secs
\end{verbatim}
\caption{Ghoul's build process}
\label{fig:ghoul_build_process}
\end{figure}

We have added additional automatic code quality checking tools to Ghoul's automatic build:

\begin{description}
  \item{\textbf{jUnit}\footnote{\url{http://junit.org}}} 
    jUnit is the framework for writing repeatable unit tests for Java code.
  \item{\textbf{JaCoCo}\footnote{\url{www.eclemma.org/jacoco/}}}
    JaCoCo is a code coverage library which automatically analyzes code executed by jUnit tests and produces an HTML or XML report summarizing code coverage.

  \item{\textbf{PMD}\footnote{\url{http://pmd.sourceforge.net}}}
    PMD is a source code analyzer.
    It finds common programming flaws like unused variables, empty catch blocks, unnecessary object creation etc.
  \item{\textbf{Findbugs}\footnote{\url{http://findbugs.sourceforge.net/}}}
    Findbugs is a static analysis tools which looks for bugs in Java's code.
    It can detect such bugs are code smells as: unused variables, null value dereference, use of \texttt{AtomicBoolean} for comparison etc.
    
\end{description}

We haven't included dfuntest's test into the automatic build, because this is a long task.
However dfuntest's testing suite is always run manually to confirm code's correctness.

\subsection{Usage}

Although Ghoul is mainly designed to be used as a library, it is also possible to run it as a standalone application.
In standalone mode Ghoul additionally exposes an RPC-over-HTTP interface over which it is possible to query and manipulate the DHT node (shown in table \ref{tab:http_rpc}).

An example session which runs 2 registrars and 3 DHT nodes is shown in figures 
\ref{fig:ghoul_manual_run} and \ref{fig:ghoul_manipulation}.
In the session we use curl to send RPC-over-HTTP queries to DHT nodes.
First we start registrars and then DHT nodes.
Afterwards we get routing tables of the first and third DHT node.
Then we put \texttt{DATA} string under the key \texttt{100}.
Later we ask the third node get all replicas of the data under key \texttt{100}.
The data returned is the \texttt{DATA} string encoded with BASE64 encoding.

\begin{figure}[h]
\begin{verbatim}
> java -cp ghoul-core-0.1.jar:lib/* me.gregorias.ghoul.interfaces.RegistrarMain\
  registrar0.xml > /dev/null &

> java -cp ghoul-core-0.1.jar:lib/* me.gregorias.ghoul.interfaces.RegistrarMain\
  registrar1.xml > /dev/null &

> java -cp ghoul-core-0.1.jar:lib/* me.gregorias.ghoul.interfaces.Main \ 
  kademlia0.xml >/dev/null &

> java -cp ghoul-core-0.1.jar:lib/* me.gregorias.ghoul.interfaces.Main \ 
  kademlia1.xml >/dev/null &

> java -cp ghoul-core-0.1.jar:lib/* me.gregorias.ghoul.interfaces.Main \ 
  kademlia2.xml >/dev/null &

> curl -X POST 127.0.0.1:10000/start

> curl -X POST 127.0.0.1:10001/start

> curl -X POST 127.0.0.1:10002/start
\end{verbatim}
\caption{Ghoul's starting commands}
\label{fig:ghoul_manual_run}
\end{figure}

\begin{figure}[h]
\begin{verbatim}
> curl -X GET 127.0.0.1:10000/get_routing_table
{"nodeInfo":[{"inetAddress":"localhost","port":9001,
    "key":"fca426586c9a211513c4338e975c5508250c1a0"},
{"inetAddress":"localhost","port":9002,
    "key":"2d1386c9c601676189faa7790b60dbeda3ed3e9b"}]}

> curl -X GET 127.0.0.1:10001/get_routing_table
{"nodeInfo":[{"inetAddress":"localhost","port":9000,
    "key":"15624f385826cae60bef58da5b53b4dc1cf070bd"},
{"inetAddress":"localhost","port":9002,
    "key":"2d1386c9c601676189faa7790b60dbeda3ed3e9b"}]}

> curl -X POST --header "Content-Type:application/octet-stream" \ 
--data-binary DATA 127.0.0.1:10000/put/100

> curl -X GET 127.0.0.1:10002/get/100
["REFUQQ==","REFUQQ==","REFUQQ=="]
\end{verbatim}
\caption{Ghoul's status query and DHT manipulation}
\label{fig:ghoul_manipulation}
\end{figure}

\section{Implementation}
\label{sec:implementation}

The core interface of the protocol is \texttt{KademliaRouting} (shown in figure \ref{fig:routing_interface}).
Implementations of this interface should implement the Kademlia protocol with Ghoul extensions.
One of the focus of Ghoul's code is modularizabilty and \texttt{KademliaRouting} is an example of that focus.
First, \texttt{KademliaRouting} is an interface, although there is only one implementation of it in the public part of the library's code.
However, because it is an interface it is possible to easily mock it in unit-tests.
\texttt{KademliaRouting} has another implementations in unit-testing code, e.g. \texttt{StaticKademliaRouting}, which has static routing table.
This allows creation of proper, isolated unit-tests that test non-trivial scenarios and do not depend on complex, error-prone dependencies.
Second, \texttt{KademliaRouting} does not implement storage functionality.
Storage is done by \texttt{KademliaStore} class.
Such division of responsibilities is also an example of Single Responsibility
Principle - one class should have only one responsibility.

\begin{figure}[tbp]
\begin{lstlisting}
public interface KademliaRouting {
  /**
   * Find size number of nodes closest to given {@link Key}.
   *
   * @param key key to look up
   * @param size number of nodes to find
   * @return up to size found nodes
   */
  Collection<NodeInfo> findClosestNodes(Key key, int size) throws InterruptedException,
      KademliaException;

  /**
   * @return hosts present in the local routing table.
   */
  Collection<NodeInfo> getFlatRoutingTable();

  /**
   * @return Key representing this peer
   */
  Key getLocalKey();

  /**
   * @return is kademlia running.
   */
  boolean isRunning();

  /**
   * Registers neighbour listener which will receive notifications about newly added nodes.
   *
   * @param listener listener to register
   */
  void registerNeighbourListener(NeighbourListener listener);

  /**
   * Unregisters neighbour listener if any is present.
   */
  void unregisterNeighbourListener();

  /**
   * Connect and initialize this peer.
   */
  void start() throws KademliaException;

  /**
   * Disconnects peer from network.
   */
  void stop() throws KademliaException;
}
\end{lstlisting}
\caption{\texttt{KademliaRouting} interface}
\label{fig:routing_interface}
\end{figure}

{\texttt{KademliaRoutingImpl}'s constructor} is shown in figure \ref{fig:routing_constr_header}.
This constructor shows dependencies of \texttt{KademliaRoutingImpl}.
Functions such as: discovering current internet address
(\texttt{NetworkAddressDiscovery}), sending messages to given network address
(\texttt{MessageSender}), background thread execution
(\texttt{ScheduledExecutorService}), are realized by interfaces.
This allows custom definition of those functionalities by the user.
This is realization of yet another principle called dependency inversion - dependencies of classes should be provided to the classes not created by it.
Again, the biggest strength of such approach is mostly visible in unit tests.
Since network code is abstracted by interfaces, unit-tests may use fake implementations which transmit messages in memory and inject failures arbitrarily.
Additionally, users of the Ghoul library may, for example, connect \texttt{KademliaRoutingImpl} with their own network code.
Large number of parameters is sometimes considered a code smell, but dependency inversion is a more important consideration in this case.
Additionally a builder design pattern is used for creating instances of \texttt{KademliaRouting}.

\begin{figure}[tbp]
\begin{lstlisting}
KademliaRoutingImpl(Key localKey,
                    NetworkAddressDiscovery networkAddressDiscovery,
                    MessageSender sender,
                    ListeningService listeningService,
                    int bucketSize,
                    int alpha,
                    Collection<NodeInfo> initialKnownPeers,
                    long messageTimeout,
                    TimeUnit messageTimeoutUnit,
                    long heartBeatDelay,
                    TimeUnit heartBeatDelayUnit,
                    PersonalCertificateManager personalCertificateManager,
                    CertificateStorage certificateStorage,
                    PrivateKey personalPrivateKey,
                    ScheduledExecutorService scheduledExecutor,
                    Random random);
\end{lstlisting}
\caption{\texttt{KademliaRoutingImpl}'s constructor}
\label{fig:routing_constr_header}
\end{figure}
