\chapter{Ghoul system description}
Ghoul system is built on top of Kademlia DHT protocol. Each node in the system
is an independent agent which acts as a Ghoul node and communicates with other
nodes using messages sent over network transmission. 

Every node acts as a DHT node, that is it initaties and maintain its routing
table and answers queries. Additionally each node is responsible for maintaining
the security of the entire network by participation in P2P certificate
revocation propagation, maintainance of its security certificates and answer in
security queries.

A relatively small set of nodes, called registration nodes, is responsible for
faciliting node's join into network by using distributed random key generation
and certifacte issuance.

[TODO description of chapter]
This chapter will first describe data structured maintained by each node and
messages available in the system in Section [TODO ref], then in Section [TODO ref]
the general protocol for normal DHT operation will be described and in Section
[TODO ref] I will describe security protocols for key generation.

\section{Overview}
Assumption about threats, network (synchrony etc.)

\section{Protocols}
\subsection{Challenge protocol}
In some neuralgical and vulnerable points in the protocol we may intent to limit
a number of requests a node can make using cryptographic challenges. This
achieves 2 goals: It significantly increases of a cost of an attack which relies
on number of queries, such as a Sybil attack, and provides a throttle mechanism
to prevent a node overload.

Whenever the protocol requires the node sending a query or a request to provide
a proof-of-work for this request the following protocol is used:


\begin{msc}{Challenge protocol}
\setlength{\instdist}{9cm}
\setlength{\envinstdist}{3cm}
\declinst{client}{C}{Client}
\declinst{server}{S}{Server}
\mess{Send challenge request}{client}{server}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
Choose a random nonce\\
$r\in\{0,1\}^*$, difficulty $p \in \N$, $t := \text{current time}$.
Save the nonce into active puzzles list. If the answer does not arrive withing
time $T_0$, remove the nonce from the list.
\end{minipage}}{server}
\nextlevel[9]
\mess{Send challenge $m_2 := (t, r, p)_{s_{pr}}$}{server}{client}
\nextlevel[1]
\action*{
\begin{minipage}{4cm}\centering
  Find $s$ such that $H(r || s)$ has $p$ last bits equal to zero.
\end{minipage}}{client}
\nextlevel[4]
\mess{Send solution $m_3 := (m_2, s, c_{pub})_{c_{pr}}$}{client}{server}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
Check the validity of the solution. Remove the nonce from active puzzles list.
\end{minipage}}{server}
\nextlevel[4]
\end{msc}

The validity check consists of: veryfying signature of $m_2$, checking whether
nonce is in active puzzles list, checking time, veryfying the solution.

$m_3$ serves as a proof-of-work and may be accompanied by the request to the
server.

Note that this protocol requires the server to use some space in order to save
the nonce. Depending on the size of a timeout and number of possible request per
second this may provide a denial-of-service vulnerability. If this is a possible
threat the application designer may choose to omit saving and nonce checking and
instead save the nonce after the puzzle has been saved for time $T_0$ and later
check whether it given nonce is not in the list. [TODO perhaps this is much
better solution and should be the default. It prevents repeat message attacks]

\subsection{Robust distributed random key generation}

In Ghoul honesty of registrars is not assumed. In case of a single centralized
registrar such a node would greatly facilitate in an eclipse attack by
assigning to colluding nodes keys close to a target. Therefore a distributed
scheme is needed.

Here  I will present a distributed protocol which gerates a random key that is
unbiased if at least one node is honest. More formally:

\begin{theorem}
  Given a list $R = \langle r_1, \ldots, r_n \rangle$ of $n \geq 2$ nodes known
  to all nodes in $R$ the random key generation protocol generates an unbiased
  random key known to all participants if at least one node is honest and all
  nodes respond according to the protocol in a timely manner. Even in the case
  of a byzantine failure then all nodes that generate a key generate the same
  key that is unbiased if at least one node is honest.
\end{theorem}

In \ref{fig:key_gen_alg} the protocol is presented.

\begin{figure}
  \label{fig:key_gen_alg}
  \begin{algorithmic}[1]
  \STATE $k_i \leftarrow $ random key
  \STATE $(h_i, s_i) \leftarrow $ bit commitment string and solution commiting
  $k_i$
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \STATE Send $(h_i)_{i}$ to $r_j$
  \ENDFOR
  \STATE Wait $T$ seconds till all messages of the form $(h_j)_j$ are received
  from other nodes. If timeout happens then abort.
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \STATE Send $\left( (h_1)_1, \ldots, (h_n)_{n}, k_i, s_i\right)_i$ to $r_j$
  \ENDFOR
  \STATE Wait $T$ seconds till all messages of the above form are received
  from other nodes. If timeout happens then abort. If any message is not
  coherent to the rest then abort.
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \IF{$b_j$ is not a bit commitment of $k_j$}
      \STATE Abort protocol.
    \ENDIF
  \ENDFOR
  \STATE $k \leftarrow k_1 \oplus \ldots \oplus k_n$
\end{algorithmic}
  \caption{Distributed key generation algorithm generating random key $k$}
\end{figure}


\begin{msc}{Distributed key-generation}
\setlength{\instdist}{5.5cm}
\setlength{\envinstdist}{3cm}
\declinst{ra}{}{RA}
\declinst{rb}{}{RB}
\declinst{rc}{}{RC}
\action*{
\begin{minipage}{4cm}\centering
  Generate random key $r_A$ and generate bit-commitment string from that key
  $h_A$.
\end{minipage}}{ra}
\nextlevel[5]
\mess{}{ra}{rb}
\mess{$(h_A)_A$}{ra}{rc}
\nextlevel[2]
\mess{$(h_B)_B$}{rb}{ra}
\nextlevel[2]
\mess{$(h_C)_C$}{rc}{ra}
\nextlevel[2]
\mess{}{ra}{rb}
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_A$}{ra}{rc}
\nextlevel[2]
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_B$}{rb}{ra}
\nextlevel[2]
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_C$}{rc}{ra}
\end{msc}

The protocol uses $O\left(n^2\right)$ messages and is vulnerable to an attack in
which an attacker simply does not participate in it. However in the large scope
of the system it's not an issue, because we assume that introducing a registrar
requires an organization approval which is a nontrivial barrier of entry and
later any malicious nodes may be easily detected and removed from the
centralized lists should it become compromised.

\subsection{Node join protocol}

Every node in order to participate in the DHT network is required to have a node
certificate. Node certificate is a collection of certificates from registitration
nodes certyfying validity of node identification ([TODO tuple of DHT ID and
public key]). A certificate provided by registration nodes is a tuple
$\left(\text{node}_{ID}, \, \text{expiration date}, \, \text{signature}\right)$.
Certificate serves as a proof to other nodes that the key in the node ID has been
generated by that registration authority and that the registration authority
allowed this node to join the DHT.

The system's threat model allows some registration authorities to be malicious
and potentially generate biased keys. The node join protocol prevents such nodes
from performing a successful attack. Given $m$ malicious nodes the node join
protocol at least $m+1$ certificates. The following scheme assumes that $m = 1$.

\begin{msc}{Node join protocol}
\setlength{\instdist}{5.5cm}
\setlength{\envinstdist}{3cm}
\declinst{client}{C}{Client}
\declinst{ra}{RA}{Registrar A}
\declinst{rb}{RB}{Registrar B}
\mess{Perform challenge protocol}{client}{ra}
\nextlevel[2]
\mess{Perform challenge protocol}{client}{rb}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
  Has received nonces $r_A, r_B$ during the challenge protocol.
\end{minipage}}{client}
\nextlevel[4]
\mess{$(r_A, r_B)$}{client}{ra}
\nextlevel[2]
\mess{$(r_A, r_B)$}{client}{rb}
\nextlevel[2]
\mess{$(r_A, r_B)_A$}{ra}{client}
\nextlevel[2]
\mess{$(r_A, r_B)_B$}{rb}{client}
\nextlevel[2]
\mess{$(r_A, r_B)_B$}{client}{ra}
\nextlevel[2]
\mess{$(r_A, r_B)_A$}{client}{rb}
\nextlevel[2]
\referencestart{r}{robust key-generation protocol}{ra}{rb}
\nextlevel[2]
\gate[r][b]{out}{rleft}
\mess{\parbox{4cm}{Node certificates \\ signed by A and B\\}}{rleft}{client}
\nextlevel[1]
\referenceend{r}
\end{msc}


\subsection{Certificate revocation}

[TODO the rest is prelimenary]
\section{Overview}


\section{Data structures and message}

\subsection{Core DHT data structures}
\subsubsection{Data types}
\begin{description}
  \item[KademliaKey] 160-bit number used to identify hosts in the DHT. 
  \item[PublicKey] A cryptographic public key.
  \item[PrivateKey] A cryptographic private key.
  \item[GhoulKeyValidityCertificate] A certificate which certifies randomness of
    given KademliaKey and PublicKey.
  \item[KeyIPPair] Association of kademlia key to ip address.
  \item[RoutingTable] A Kademlia routing table. It consists of 160 buckets
    containing \textbf{KeyIPPairs} of common Key prefixes.
\end{description}

\subsection{Messages/Operations}
\subsubsection{Kademlia messages}
The general format of messages looks as follows:

Each message comes with a s
\begin{description}
  \item[Ping] Fields: Sender's KeyIPPair, Destination Key.  This message request
    a pong message from destination. A heartbeat message. Used to update
    KeyIPPair and check whether recipient is alive.
  \item[Pong] Fields: Sender's KeyIPPair, Destination Key.  This is a response
    message to pong.
\end{description}

\subsubsection{Ghoul messages}
\begin{description}
  \item[CertificateInfo]   
  \item[CertificateInfo]   
\end{description}

\subsection{Messages/Operations}

Perhaps we can run a recursive algorithm to discover size of network

In a centralized solution we can have a server which will:
  assign keys and check IP address uniqueness
  help with anonymous rogue node discovery
  Keey certifites and revocations

Each node can keep a signed proof that a given node promised to keep given
key,value. Breaking this promise means that a node should be revoked.

If each certificate has a validity period than we can control the ever-growing
size of network.

Octopus

I think I need to focus on peer, super-peer infrastructure. Each network will
have a few super-peers, special kinds of peers, known by every node, that will
be able to: sign someone's key, revoke someone's certificate, perhaps force to
run a query.
unlikely (but possible to be malicious), 

The current solution looks like this.

\subsubsection{Data}
Each peer in kademlia network has following values:
KID - Public 160-bit kademlia key identifying its position in kademlia network.
PUBLIC\_KEY, PRIVATE\_KEY - key pair used by this node for cryptography operation.
CERTIFICATE\_CHAIN - Chain of certificates (up to a super-peer) proving that a
given KID has been assigned to given public key.

\subsubsection{Messages}
Explain node structure and fields.

\paragraph{Core DHT operations}
Each message contains

PING - Query a node for its alive status. 
PONG - A response to PING message containing current node information.
FIND - Return the closest nodes to given node.
FIND\_RESPONSE - Duh.

\paragraph{Key allocation}

ASSIGN\_KEY - A message starting a key allocation sent to super-peers.
ASSIGN\_KEY\_RESPONSE - A message containing signed key.

\paragraph{Security operations}

Octopus operations

GET\_REVOCATIONS

\subsubsection{Operations}
\paragraph{Key allocations}
\paragraph{Core DHT operations}
Think about DOS when nodes requires someone to put new elements. Perhaps limit
number of a available messages 
\paragraph{Random Validity checks}
\paragraph{Revocation mechanism}
\paragraph{DO we use trust network?}

\section{Core DHT protocol}

Here will be general Kademlia.

\section{Operations}

\section{Algorithms and general operations}

\subsection{Peer's data}
Every peer in the network is contains the following data required for the
system:

\begin{description}
  \item[dhtkey] 160-bit key either generated randomly and assigned by
    super-peers or just generated randomly in case of super-peers.
  \item[routing\_table] A kademlia
\end{description}

