\chapter{Ghoul system description}
\section{Goals}
I decided to build Ghoul to fill a niche of secure open-source DHT network
implementation. In my experience it is difficult to find a good open-source
implementation of kademlia. By good I mean one that satisfies all of the
following criterias:

\begin{description}
  \item{Simplicty} Implementation of kademlia should do only one thing: operate
    according to the kademlia protocol.
  \item{Extensibility} If I want to extend the network protocol with a NAT
    traversal mechanism I should not be required to modify large portion of the
    library network communication stack.
  \item{Documentation} An open-source project should have maintained
    documentation to help others contribute/use it.
  \item{Robustness} Implementation should not break after 1 hour of usage on
    small sized network in Planetlab.
\end{description}

I couldn't find an implementation that satisfies all of the above in Java and
none that would satisfiaibly claim to be secure in any language.

Solutions used in KAD network and designed for Mainline DHT use IP address to
prevent Sybil attack and arbirtary ID choice, this works against unsophisticated
attacker, but has serious problems stemming from the fact that IP was not
designed for this use case. IP spoofing, IPv6 privacy extensions and lack of
anonimity are serious concerns that either disarm such solution or introduce a
different serious flaw. I feel that lack of adoption of security measures
that are present in the research literature stems from the stereotype that such
measures are either hard to implement, slow, hard to satisfy their dependencies,
or needlessly complicate usage of the network. I wanted to find whether it was
possible to design and build DHT that satisfies following constraints:

\begin{description}
  \item{Security} The DHT should be resistant to common Sybil and eclipse
    attacks.
  \item{Performance} The DHT should be as performant as the original protocol
    where possible, especially in common use cases of finding a node and data
    storage. In other cases the time of operation should be practical, meaning
    that time or message complexity should not be greater than $O(\log n)$ for
    network of size $n$.
  \item{Simplicity} It should be simple to use. User should not be forced to
    perform an extensive set up, or configure a large file to just start the
    DHT.  The entire scheme should be simple to describe. User or developer
    should be able to understand how the protection schemes work and be able to
    reason how it would behave in his scheme. It should also be simple
  \item{Extensibility} The application develop should be able to extend the
    system with his own security mechanism easily if so desired.
\end{description}

When building the system I assume standard threats and network conditions that
is:

\begin{itemize}
  \item An attacker may introduce colluding nodes into the system, but has
    limited computing and communication power.
  \item For network communication there is point-to-point message passing
    primitive which may fail to deliver.
  \item Nodes may fail arbitrarily.
\end{itemize}

I believe such system is possible to accomplish and in this chapter I present
its design.

\section{Overview}
Ghoul system is built on top of Kademlia DHT protocol. Each node in the system
is an independent agent which acts as a Ghoul node and communicates with other
nodes using messages sent over network transmission.

There two kinds of nodes in the system: a DHT node and a registration authority.
The DHT node is the kademlia node extended with security measures. It initaties
and maintain its routing table and anwers queries. Additionally each node is
responsible for maintaining the security of the entire network by participation
in P2P certificate revocation propagation, maintainance of its security
certificate, and answer in security queries.

A small set of nodes, called registration nodes, is responsible for faciliting
nodeâ€™s join into network by using distributed random key generation and
certificate issuance. Registration nodes are distributed version of central
authority, with a twist that they a few of them might be malicious. Their
existance is motivated by the fact that it is very hard to guarantee random key
generation and verification in distributed setting, on the other hand I want to
provide administrative scalability where application's owner may allow other
parties to provide their registration node's for the protocol and not worry
whether they have pure intentions as long they do not collude.

\section{Data structures}

\subsection{Public key cryptography}
Ghoul uses public key cryptography for node authentication and certification.
Every dht node and registration node generates a public/private key pair on its
first entry. The private key is always kept private, but public can and should
be propagated. Additionally public keys of registration nodes are known globally
by all nodes.

To participate in the network each DHT requires a set of \textbf{certificate}.
Certificate is a tuple of: (\texttt{NODE\_PUB\_KEY}, \texttt{NODE\_DHT\_KEY},
\texttt{EXPIRATION\_DATETIME}) signed with a registration's node private key
such that it is known which node signed it. Such certificate is given by the
registration node together with \texttt{NODE\_DHT\_KEY} as a proof that that
node is valid and its key was generated randomly by the registration node or in
a disitributed way by a set of registration nodes. If the key is generated by a
group of registration nodes then all of them provide also the certificate.

We say that node is valid if it has at least $m$ non-expired, non-revocated
certifacates from different hosts. The parameter $m$ should be set to such a
value that we are sure that there might at most $m-1$ malicious registration
nodes.

Every node maintains a store for valid certificates that it has received. This
store may limited in size. In such a case a node may remove certificates last
seen node's or certificates close to expiration. Additionally every node in the
routing table must have a valid certificate in the store, otherwise it should be
removed. If a neighbours certificate is close to expiration than it should be
sent a \texttt{PING} to get a new certificate.

\subsection{Messages}
Ghoul extends each DHT message with following fields:
\begin{description}
  \item{\texttt{certificateRequest}} Signifies that a response to this message
    should contain a list of certificates. This is field is set when the
    recipient is considered to be a neighbour or potential neighbour and either
    its certificates are not present, not valid, or close to expiration.
  \item{\texttt{certificates}} A list of valid certificates provided by the
    registration authority.
  \item{\texttt{signature}} Signature signed by the sender's private key.
\end{description}

Just like normal kademlia messages are used for routing table maintainance so
similarly in Ghoul we attach security information to them. Only the list of
certificates may have a larger size (each certificate has a size of $\approx$
1KB), but it is sent only sporadically.

Each one of those additional fields is optional. If the signature field is not
provided it means that the node is not interested in being part of the network
and instead just uses it to find information. That is considered normal
behaviour, such node is not added to the routing table (it may have possibly not
even provided its key information), and is simply responded with appropiate
response. Otherwise every node should always sign its messages.

The \texttt{certificateRequest} field is set if all of the following conditions
are met:

\begin{itemize}
  \item The recipient's certificate is not present in the store or is close to
    expiration.
  \item The recipient is in the routing table or may be considered a candidate.
\end{itemize}

If the \texttt{certificateRequest} field is set then the recipient should attach
list of certificates to its response or if no response would be normally given
then it should respond with a \text{PONG} message.

If a response to the message with the \texttt{certificateRequest} does not have
a valid list of certificates then it is discarded.

\section{Protocols}
\subsection{Challenge protocol}
In some neuralgical and vulnerable points in the protocol we may intent to limit
a number of requests a node can make using cryptographic challenges. This
achieves 2 goals: It significantly increases of a cost of an attack which relies
on number of queries, such as a Sybil attack, and provides a throttle mechanism
to prevent a node overload.

Whenever the protocol requires the node sending a query or a request to provide
a proof-of-work for this request the challenge protocol is used
(\ref{fig:chal_prot}).

\begin{figure}
\begin{msc}{Challenge protocol}
\setlength{\instdist}{9cm}
\setlength{\envinstdist}{3cm}
\declinst{client}{C}{Client}
\declinst{server}{S}{Server}
\mess{Send challenge request}{client}{server}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
Choose a random nonce\\
$r\in\{0,1\}^*$, difficulty $p \in \N$, $t := \text{current time}$.
Save the nonce into active puzzles list. If the answer does not arrive withing
time $T_0$, remove the nonce from the list.
\end{minipage}}{server}
\nextlevel[11]
\mess{Send challenge $m_2 := (t, r, p)_{s_{pr}}$}{server}{client}
\nextlevel[1]
\action*{
\begin{minipage}{4cm}\centering
  Find $s$ such that $H(r || s)$ has $p$ last bits equal to zero.
\end{minipage}}{client}
\nextlevel[4]
\mess{Send solution $m_3 := (m_2, s, c_{pub})_{c_{pr}}$}{client}{server}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
Check the validity of the solution. Remove the nonce from active puzzles list.
\end{minipage}}{server}
\nextlevel[4]
\end{msc}
  \caption{Challenge protocol}
  \label{fig:chal_prot}
\end{figure}

The validity check consists of: veryfying signature of $m_2$, checking whether
nonce is in active puzzles list, checking time, veryfying the solution.

$m_3$ serves as a proof-of-work and may be accompanied by the request to the
server.

Note that this protocol requires the server to use some space in order to save
the nonce. Depending on the size of a timeout and number of possible request per
second this may provide a denial-of-service vulnerability. If this is a possible
threat the application designer may choose to omit saving and nonce checking and
instead save the nonce after the puzzle has been saved for time $T_0$ and later
check whether it given nonce is not in the list. [TODO perhaps this is much
better solution and should be the default. It prevents repeat message attacks]

\subsection{Robust distributed random key generation}

In Ghoul honesty of registrars is not assumed. In case of a single centralized
registrar such a node would greatly facilitate in an eclipse attack by
assigning to colluding nodes keys close to a target. Therefore a distributed
scheme is needed.

Here  I will present a distributed protocol which gerates a random key that is
unbiased if at least one node is honest. More formally:

\begin{theorem}
  Given a list $R = \langle r_1, \ldots, r_n \rangle$ of $n \geq 2$ nodes known
  to all nodes in $R$ the random key generation protocol generates an unbiased
  random key known to all participants if at least one node is honest and all
  nodes respond according to the protocol in a timely manner. Even in the case
  of a byzantine failure then all nodes that generate a key generate the same
  key that is unbiased if at least one node is honest.

  The chance that the malicious participant may manipulate the protocol so that
  this theorem does not hold is cryptographically negligible.
\end{theorem}

The protocol uses bit-commitment. Bit-commitment is a cryptographic protocol
such that:

[TODO bit-commitmen description

The protocol that satisfies those properties is defined in \ref{fig:key_gen_alg}.

It consists of 3 phases:
\begin{enumerate}
  \item Commit and broadcast random number used to generate the key. This phase
    is used so that every node commits to its random number and can not change
    it later.
  \item Broadcast all received messages to others. This step ensures that every
    honest node has received the same set of messages and will generate the same
    key. If any node has sent inconsistent messages to honest nodes
    than this will be detected here.
  \item Broadcast key to unlock commitment.
\end{enumerate}

One may recognize that this protocol consist of first two phases of a 3-phase
byzantine failure protection protocol. Which is why it has its nonmalleability
properties.

\begin{figure}
  \begin{algorithmic}[1]
  \STATE $k_i \leftarrow $ random key
  \STATE $(h_i, s_i) \leftarrow $ bit commitment string and solution commiting
  $k_i$
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \STATE Send $(h_i)_{i}$ to $r_j$
  \ENDFOR
  \STATE Wait $T$ seconds till all messages of the form $(h_j)_j$ are received
  from other nodes. If timeout happens then abort.
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \STATE Send $\left( (h_1)_1, \ldots, (h_n)_{n}, k_i, s_i\right)_i$ to $r_j$
  \ENDFOR
  \STATE Wait $T$ seconds till all messages of the above form are received
  from other nodes. If timeout happens then abort. If any message is not
  coherent to the rest then abort.
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \IF{$b_j$ is not a bit commitment of $k_j$}
      \STATE Abort protocol.
    \ENDIF
  \ENDFOR
  \STATE $k \leftarrow k_1 \oplus \ldots \oplus k_n$
\end{algorithmic}
  \caption{Distributed key generation algorithm generating random key $k$}
  \label{fig:key_gen_alg}
\end{figure}

An example of this protocol for 3 registrars is shown in
\ref{fig:key_gen_example}.

\begin{figure}
\begin{msc}{Distributed key-generation}
\setlength{\instdist}{5.5cm}
\setlength{\envinstdist}{3cm}
\declinst{ra}{}{RA}
\declinst{rb}{}{RB}
\declinst{rc}{}{RC}
\action*{
\begin{minipage}{4cm}\centering
  Generate random key $r_A$ and generate bit-commitment string from that key
  $h_A$.
\end{minipage}}{ra}
\nextlevel[5]
\mess{}{ra}{rb}
\mess{$(h_A)_A$}{ra}{rc}
\nextlevel[2]
\mess{$(h_B)_B$}{rb}{ra}
\nextlevel[2]
\mess{$(h_C)_C$}{rc}{ra}
\nextlevel[2]
\mess{}{ra}{rb}
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_A$}{ra}{rc}
\nextlevel[2]
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_B$}{rb}{ra}
\nextlevel[2]
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_C$}{rc}{ra}
\end{msc}
\label{fig:key_gen_example}
\caption{Example of distributed key-generation for 3 registrars}
\end{figure}

The protocol uses $O\left(n^2\right)$ messages and is vulnerable to an attack in
which an attacker simply does not participate in it. However in the large scope
of the system it's not an issue, because we assume that introducing a registrar
requires an organizational approval which is a nontrivial barrier of entry and
later any malicious nodes may be easily detected and removed from the
centralized lists should it become compromised.

\subsection{Node join protocol}

Every node in order to participate in the DHT network is required to have a node
certificate. Node certificate is a collection of certificates from registitration
nodes certyfying validity of node identification ([TODO tuple of DHT ID and
public key]). A certificate provided by registration nodes is a tuple
$\left(\text{node}_{ID}, \, \text{expiration date}, \, \text{signature}\right)$.
Certificate serves as a proof to other nodes that the key in the node ID has been
generated by that registration authority and that the registration authority
allowed this node to join the DHT.H

The system's threat model allows some registration authorities to be malicious
and potentially generate biased keys. The node join protocol prevents such nodes
from performing a successful attack. Given $m$ malicious nodes the node join
protocol at least $m+1$ certificates. The following scheme assumes that $m = 1$.

\begin{figure}
\begin{msc}{Node join protocol}
\setlength{\instdist}{5.5cm}
\setlength{\envinstdist}{3cm}
\declinst{client}{C}{Client}
\declinst{ra}{RA}{Registrar A}
\declinst{rb}{RB}{Registrar B}
\mess{Perform challenge protocol}{client}{ra}
\nextlevel[2]
\mess{Perform challenge protocol}{client}{rb}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
  Has received nonces $r_A, r_B$ during the challenge protocol.
\end{minipage}}{client}
\nextlevel[4]
\mess{$(r_A, r_B)$}{client}{ra}
\nextlevel[2]
\mess{$(r_A, r_B)$}{client}{rb}
\nextlevel[2]
\mess{$(r_A, r_B)_A$}{ra}{client}
\nextlevel[2]
\mess{$(r_A, r_B)_B$}{rb}{client}
\nextlevel[2]
\mess{$(r_A, r_B)_B$}{client}{ra}
\nextlevel[2]
\mess{$(r_A, r_B)_A$}{client}{rb}
\nextlevel[2]
\referencestart{r}{robust key-generation protocol}{ra}{rb}
\nextlevel[2]
\gate[r][b]{out}{rleft}
\mess{\parbox{4cm}{Node certificates \\ signed by A and B\\}}{rleft}{client}
\nextlevel[1]
\referenceend{r}
\end{msc}
\caption{Node's join protocol}
\end{figure}

[TODO certificate refresh]

\subsection{Certificate revocation system}

\subsection{SybilControl - Limiting number of sybil nodes with computational
puzzles}
\subsubsection{Goals}
  Verifiable random key generation in Kademlia is a defense against eclipse
  style attacks, which in kademlia are much harder to launch than in other
  DHTs, such as Chord, due to nonstrict routing tables and redundant, iterative
  routing algorithm. [TODO citation]. However eclipse attack might not be
  necessary if attacker can perform a Sybil attack. Although this the scope of
  this attack will be limited by the centralized authority thanks to the use of
  computation puzzles, it just limits the rate of entry.

  The centralized authority allows for implementation of various anti-sybil
  check schemes, but it increases responsibilities of those nodes which we might
  want to keep as simple as possible. So in order to provide a defense against
  Sybil attack Ghoul incorporates SybilControl into its mechanisms.

\subsubsection{SybilControl mechanism}
  SybilControl is fully described in \cite{li12} here I will describe the core
  mechanism as it is used in Ghoul. 

  To limit the number of sybil nodes SybilControl requires that the nodes
  generate a cryptographic puzzle periodically and solve it. To verify that this
  puzzle is generated honestly it includes similarly generated puzzles prpagated
  from its neighbours. The puzzle string for node $A$ is $C_{A-new}$, who has
  received puzzles $C_{B_i}$ from its neighbours $B_{i}$ where:

  \begin{eqnarray*}
      R_{A-new} &=& B_1||C_{B_1}||\ldots||B_n||C_{B_n}||r_A||C_{A-old}\\
    C_{A-new} &=& H\left(R_{A-new}\right)
  \end{eqnarray*}

  $r_A$ is a random string generated by $A$. $H$ is a one-way function such as
  \texttt{SHA-2}. This is to ensure that $r_A$ is not specially prepared to make
  the puzzle solving easy.

  The solution to the puzzle is such a string $S$ that:

  \[ h = H\left(A||C_A||S\right)\]

  has at least $p$ last bits equal to zero.

  The entire puzzle state $P$ consists ofm: the solution $S_P$, the challenge
  $C_P$ and the record state $R_P$. Generated puzzle states are kept for some
  globally defined for verification purposes.

  \paragraph{Neighbour node verification}
  To verify that a neighbour node has done its proof-of-work it is asked to send
  its latest puzzle state $P$. Then the asking node checks whether this is a
  valid, solved puzzle state and 

  \paragraph{Non-neighbour node verification}
  To verify that a non-neighbour node has solved its puzzle in the recent past we
  need to check that our recent challenge has influenced its puzzle. To do that
  we find a path between us and the non-verified node. We query nodes in the
  path for puzzle state history. The node verification is then equivalent to
  finding out in these puzzle state history all puzzles that have influenced the
  puzzle of the node under verification. The node is verified iff a puzzle that
  we have produced is among them.

\subsubsection{SybilControl in Ghoul}
  SybilControl requires additional consideration as to how it integrates with
  kademlia.

  First off the protocol loosely defines what constitutes a neighbour. An
  uncareful implementation of SybilControl in which every cryptographic puzzle
  propagation is included in the generation of the next puzzle may increase the
  size of the puzzle size considerably. This kind of behaviour may be used to
  slow down the DHT by gratuitous send of challenge updates to all nodes in the
  DHT. Li et al. do not take this into consideration, but this can be prevented
  by including only challenges received from nodes in the routing table and
  additionally limiting the number of included challenges to those that have
  been received in the last $2p$ seconds from the $i$ closests nodes. Where $p$
  and $i$ are globally defined constants.

  Secondly the protocol described in SybilControl has only local effects, that
  is a node that does not have an up to date puzzle will just not be included
  into the routing table. Since Ghoul uses a certification system with
  revocation it is possible for nodes to complain about others to registrars. If
  registrars find that given node is malicious or sybil they may globally revoke
  its certificate, significantly increasing the cost of a Sybil attack.

  [About additional advantages of Sybil control in Ghoul]
  [Problem with revocation spam]
