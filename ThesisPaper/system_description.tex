\chapter{Ghoul system description}
\section{Goals}
I decided to build Ghoul to fill a niche of secure open-source DHT network
implementation. In my experience it is difficult to find a good open-source
implementation of Kademlia. By good I mean one that satisfies all of the
following criterias:

\begin{description}
  \item{\textbf{Simplicty}} Implementation of Kademlia should do only one thing:
    operate according to the Kademlia protocol.
  \item{\textbf{Extensibility}} If I want to extend the network protocol with a
    NAT traversal mechanism I should not be required to modify large portion of
    the library network communication stack.
  \item{\textbf{Documentation}} An open-source project should have maintained
    documentation to help others contribute or use it.
  \item{\textbf{Robustness}} Implementation should not break after it is used
    for 1 hour on small sized network in Planetlab.
\end{description}

I couldn't find an implementation that satisfies all of the above in Java and
none that would satisfiably claim to be secure in any language.

Solutions used in KAD network and designed for Mainline DHT use IP address to
prevent Sybil attack and arbitrary ID choice, this works against unsophisticated
attacker, but has serious problems stemming from the fact that IP was not
designed for that use case. IP spoofing, IPv6 privacy extensions and lack of
anonymity are serious concerns that either disarm such solution or introduce a
serious flaw. I feel that lack of adoption of security measures that are present
in the research literature stems from the stereotype that such measures are
either hard to implement, slow, hard to satisfy their dependencies, or
needlessly complicate use of the application. With Ghoul I show that it is
possible to design and build a DHT that satisfies following constraints:

\begin{description}
  \item{\textbf{Security}} The DHT should be resistant to common Sybil and
    eclipse attacks.
  \item{\textbf{Performance}} The DHT should be as performant as the original
    protocol where possible, especially in common use cases of finding a node
    and data storage. In other cases the time of operation should be practical,
    meaning that time or message complexity should not be greater than $O(\log
    n)$ for network of size $n$.
  \item{\textbf{Simplicity}} It should be simple to use. User should not be
    forced to perform an extensive set up, or prepare a large configuration file
    to just start the DHT.  The entire scheme should be simple to describe. User
    or developer should be able to understand how the protection schemes work
    and be able to reason how it would behave in his applicationacquire this
    certificate.
  \item{\textbf{Extensibility}} The application develop should be able to extend
    the system with his own security mechanism easily if so desired.
  \item{\textbf{Anonymity}} The security mechanism should not compromise user
    anonymity.
\end{description}

I assume standard threats and network conditions that is:

\begin{itemize}
  \item An attacker may introduce colluding nodes into the system, but has
    limited computing and communication power.
  \item For network communication there is point-to-point message passing
    primitive which may fail to deliver and does not give any bound on delivery
    time.
  \item Nodes may fail arbitrarily.
\end{itemize}

In this chapter I present protocols that create Ghoul.

\section{Overview}
Ghoul system is built on top of Kademlia DHT protocol. Each node in the system
is an independent agent which acts as a Ghoul node and communicates with other
nodes using messages sent over network transmission.

There two kinds of nodes in the system: a DHT node and a registration authority.
The DHT node is the Kademlia node extended with security measures. It initiates
and maintain its routing table and answers queries. Additionally each node is
responsible for maintaining the security of the entire network by participation
in P2P certificate revocation propagation, maintenance of its security
certificate, and answer in security queries.

A small set of nodes, called registration nodes, is responsible for facilitating
node’s join into network by using distributed random key generation and
certificate issuance. Registration nodes are distributed version of central
authority, with a twist that they a few of them might be malicious. Their
existence is motivated by the fact that it is very hard to guarantee random key
generation and verification in distributed setting, on the other hand I want to
provide administrative scalability where application's owner may allow other
parties to provide their registration nodes for the protocol and not worry
whether they have pure intentions as long as a single node is honest.

\section{Data structures}

\subsection{Public key cryptography}
Ghoul uses public key cryptography for node authentication and certification.
Every DHT node and registration node generates a public/private key pair on its
first entry. The private key is always kept private, but public can and should
be propagated. Additionally public keys of registration nodes are known by all
nodes.

To participate in the network a DHT node requires a \textbf{certificate}.
Certificate is a tuple of form:
(\texttt{NODE\_PUB\_KEY},~\texttt{NODE\_DHT\_KEY},~\texttt{EXPIRATION\_DATETIME})
signed with a registration node's private key such that it is known which node
signed it. Such certificate is given by the registration node together with
\texttt{NODE\_DHT\_KEY} as a proof that that node is valid and its key was
generated randomly by the registration node or in a distributed way by a set of
registration nodes. If the key is generated by a group of registration nodes
then all of them provide a certificate.

We say that node is valid if it has at least $m$ non-expired, non-revoked
certificates from different hosts. The parameter $m$ should be set to such a
value that we are sure that there might at most $m-1$ malicious registration
nodes.

Every node maintains a store for valid certificates that it has received. This
store may be limited in size. In such a case a node may remove certificates last
seen node's or certificates close to expiration. Additionally every node in the
routing table must have a valid certificate in the store, otherwise it should be
removed. If a neighbors certificate is close to expiration than a \texttt{PING}
should be sent to get an unpdated certificate.

\subsection{Messages}
Ghoul extends each DHT message with following fields:
\begin{description}
  \item{\texttt{certificateRequest}} Signifies that a response to this message
    should contain a list of certificates. This field is set when the recipient
    is considered to be a neighbor or potential neighbor and either its
    certificates are not present, not valid, or close to expiration.
  \item{\texttt{certificates}} A list of valid certificates provided by the
    registration authority.
  \item{\texttt{signature}} Signature signed by the sender's private key.
\end{description}

Just like normal Kademlia messages are used for routing table maintenance so
similarly in Ghoul we attach security information to them. Only the list of
certificates may have a larger size (each certificate has a size of $\approx$
1KB), but it is sent only sporadically.

Each one of those additional fields is optional. If the signature field is not
provided it means that the node is not interested in being part of the network
and instead just uses it to find information. That is considered normal
behavior, such node is not added to the routing table (it may have possibly not
even provided its key information), and is simply responded with appropriate
response. Otherwise every node should always sign its messages.

The \texttt{certificateRequest} field is set if all of the following conditions
are met:

\begin{itemize}
  \item The recipient's certificate is not present in the store or is close to
    expiration.
  \item The recipient is in the routing table or may be considered a candidate.
\end{itemize}

If the \texttt{certificateRequest} field is set then the recipient should attach
list of certificates to its response or if no response would be normally given
then it should respond with a \text{PONG} message.

If a response to the message with the \texttt{certificateRequest} does not have
a valid list of certificates then it is discarded.

\section{Protocols}
\subsection{Challenge protocol}
In some neuralgical and vulnerable points in the protocol we may intent to limit
the number of requests a node can make using cryptographic challenges. This
achieves 2 goals: It significantly increases of a cost of an attack which relies
on number of queries, such as a Sybil attack, and provides a throttle mechanism
to prevent a node overload.

Whenever the protocol requires the node sending a query or a request to provide
a proof-of-work for this request the challenge protocol is used
(\ref{fig:chal_prot}).

\begin{figure}
\begin{msc}{Challenge protocol}
\setlength{\instdist}{9cm}
\setlength{\envinstdist}{3cm}
\declinst{client}{C}{Client}
\declinst{server}{S}{Server}
\mess{Send challenge request}{client}{server}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
Choose a random nonce\\
$r\in\{0,1\}^*$, difficulty $p \in \N$, $t := \text{current time}$.
\end{minipage}}{server}
\nextlevel[11]
\mess{Send challenge $m_2 := (t, r, p)_{s_{pr}}$}{server}{client}
\nextlevel[1]
\action*{
\begin{minipage}{4cm}\centering
  Find $s$ such that $H(r || s)$ has $p$ last bits equal to zero.
\end{minipage}}{client}
\nextlevel[4]
\mess{Send solution $m_3 := (m_2, s, c_{pub})_{c_{pr}}$}{client}{server}
\nextlevel
\action*{
\begin{minipage}{4cm}\centering
Check the validity of the solution. Save the nonce into active puzzles list
until the validity of the puzzle has ended.
\end{minipage}}{server}
\nextlevel[4]
\end{msc}
  \caption{Challenge protocol}
  \label{fig:chal_prot}
\end{figure}

The validity check consists of: verifying signature of $m_2$, checking whether
nonce is in not in the active puzzles list, checking time, verifying the
solution.

$m_3$ serves as a proof-of-work and may be accompanied by an additional request
to the server.

Note that there is a variant to this scheme in which we save distributed nonces
and later check that they exist in the list during verification. Depending on
the duration of the timeout and number of possible queries per second this may
provide a denial-of-service vulnerability.

\subsection{Robust distributed random key generation}

In Ghoul honesty of registrars is not assumed. In case of a single centralized
registrar such a node would greatly facilitate in an eclipse attack by
assigning to colluding nodes keys close to a target. Therefore a verifiable
distributed scheme for key generation is needed.

Here  I will present a distributed protocol which generates a random key that is
unbiased if at least one node is honest. More formally:

\begin{theorem*}
  Given a list $R = \langle r_1, \ldots, r_n \rangle$ of $n \geq 2$ nodes known
  to all nodes in $R$ the random key generation protocol generates an unbiased
  random key known to all participants if at least one node is honest and all
  nodes respond according to the protocol in a timely manner. Even in the case
  of a byzantine failure then all nodes that generate a key generate the same
  key that is unbiased if at least one non-failing node is honest.

  The chance that the malicious participant may manipulate the protocol so that
  this theorem does not hold is cryptographically negligible.
\end{theorem*}

The protocol that satisfies those properties is defined in
\ref{fig:key_gen_alg}.  It uses bit-commitment scheme which is defined as
follows:

\begin{defin*}[Bit-commitment]
  Bit-commitment is a cryptographic protocol that allows one to commit a value
  such that it is hidden and may be shared with others. Later the commiter may
  reveal the commited value to participants in such a way that they can check
  that it is indeed hidden in the earlier shared commitment. If the commiter
  tries to reveal a different value then this fact is detectable.

  Typical bit-commitment use is split into two phases:
  \begin{description}
    \item{\textbf{Hiding phase}} Commiter chooses a value and creates a
      commitment which hides the value. The commiter sends the commitment to
      interested parties.
    \item{\textbf{Reveal phase}} The value and the key used to create the
      commitment are revealed. Interested parties may check that they are
      consistent with earlier commitments.
  \end{description}

  Bit-commitment protocols may be either unconditionally binding, meaning even
  computationally unbounded commiter may not reveal a different value than the
  one commited, or unconditionally hiding, meaning no participant may find out
  the commited value. It can't be both.
\end{defin*}

The random number generation protocol consists of 3 phases:
\begin{enumerate}
  \item Commit and broadcast random number used to generate the key. This phase
    is used so that every node commits to its random number and can not change
    it later.
  \item Broadcast all received messages to others. This step ensures that every
    honest node has received the same set of messages and will generate the same
    key. If any node has sent inconsistent messages to honest nodes
    than this will be detected here.
  \item Broadcast key to unlock commitment.
\end{enumerate}

One may recognize that this protocol consist of the first two phases of a
3-phase byzantine failure protection protocol. Which is the reason why it has
its non-malleability properties.

\begin{figure}
  \begin{algorithmic}[1]
  \STATE $k_i \leftarrow $ random key
  \STATE $(h_i, s_i) \leftarrow $ bit commitment string and solution commiting
  $k_i$
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \STATE Send $(h_i)_{i}$ to $r_j$
  \ENDFOR
  \STATE Wait $T$ seconds till all messages of the form $(h_j)_j$ are received
  from other nodes. If timeout happens then abort.
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \STATE Send $\left( (h_1)_1, \ldots, (h_n)_{n}, k_i, s_i\right)_i$ to $r_j$
  \ENDFOR
  \STATE Wait $T$ seconds till all messages of the above form are received
  from other nodes. If timeout happens then abort. If any message is not
  coherent to the rest then abort.
  \FOR{$j := 1$ \TO $n$, $j \neq i$}
    \IF{$b_j$ is not a bit commitment of $k_j$}
      \STATE Abort protocol.
    \ENDIF
  \ENDFOR
  \STATE $k \leftarrow k_1 \oplus \ldots \oplus k_n$
\end{algorithmic}
  \caption{Distributed key generation algorithm generating random key $k$}
  \label{fig:key_gen_alg}
\end{figure}

An example of this protocol for 3 registrars is shown in
\ref{fig:key_gen_example}.

\begin{figure}
\begin{msc}{Distributed key-generation}
\setlength{\instdist}{5.5cm}
\setlength{\envinstdist}{3cm}
\declinst{ra}{}{RA}
\declinst{rb}{}{RB}
\declinst{rc}{}{RC}
\action*{
\begin{minipage}{4cm}\centering
  Generate random key $r_A$ and generate bit-commitment string for that key:
  $h_A$.
\end{minipage}}{ra}
\nextlevel[5]
\mess{}{ra}{rb}
\mess{$(h_A)_A$}{ra}{rc}
\nextlevel[2]
\mess{$(h_B)_B$}{rb}{ra}
\nextlevel[2]
\mess{$(h_C)_C$}{rc}{ra}
\nextlevel[2]
\mess{}{ra}{rb}
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_A$}{ra}{rc}
\nextlevel[2]
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_B$}{rb}{ra}
\nextlevel[2]
\mess{$((h_A)_A, (h_B)_B, (h_C)_C)_C$}{rc}{ra}
\nextlevel[2]
\mess{}{ra}{rb}
\mess{$(r_A)_A$}{ra}{rc}
\nextlevel[2]
\mess{$(r_B)_B$}{rb}{ra}
\nextlevel[2]
\mess{$(r_C)_C$}{rc}{ra}
\nextlevel[2]
\action*{
\begin{minipage}{4cm}\centering
  If messages are consistent generate key $r := r_A \oplus r_B \oplus r_C$.
\end{minipage}}{ra}
\nextlevel[4]
\end{msc}
\caption{Example of distributed key-generation for 3 registrars}
\label{fig:key_gen_example}
\end{figure}

The protocol uses $O\left(n^2\right)$ messages and is vulnerable to an attack in
which an attacker simply does not participate in it. However in the large scope
of the system it's not an issue, because we assume that introducing a registrar
requires an organizational approval which is a nontrivial barrier of entry and
later any malicious nodes may be easily detected and removed from the
centralized lists should it become compromised.

\subsection{Node join protocol}

Every node in order to participate in the DHT network is required to have a
collection of node certificates from registrars. Certificate serves as a proof
to other nodes that the key in the node ID has been generated by that
registration authority and that the registration authority allowed this node to
join the DHT.

The node join protocol is started by a DHT node that wants to join the network.
Upon its successful completion the node acquires a DHT key generated by
registrars and a collection of certifcates tying that DHT key to his public key.

The system's threat model allows some registration authorities to be malicious
and potentially generate biased keys. The node join protocol prevents such nodes
from performing a successful attack. Ghoul takes a constant $m$ as a parameter 
inidicating maximal number of malicious registrars. The node join protocol then
requires that at least $m+1$ certificates are present for the node to be
considered valid.

The protocol is a combination of the challenge protocol and distributed random
number generation. Client node contacts any registrar requesting a challenge and
combines its solution with a join request. Then the registrar chosses $m$ other
registrars and generates random number with them. At the end all participating
registrars send their certificates.

In figure~\ref{fig:node_join_prot} an example of the node join protocol is shown
for $m=1$.

\begin{figure}
\begin{msc}{Node join protocol}
\setlength{\instdist}{5.5cm}
\setlength{\envinstdist}{3cm}
\setlength{\instwidth}{2.5cm}
\declinst{client}{C}{Client}
\declinst{ra}{RA}{Registrar A}
\declinst{rb}{RB}{Registrar B}
\nextlevel
\referencestart{c}{challenge protocol}{client}{ra}
\nextlevel[5]
\mess{send solution and request join}{client}{ra}
\nextlevel
\referenceend{c}
\nextlevel[1]

\action*{
\begin{minipage}{4cm}\centering
  choose $m$ registrars to perform random number generation
\end{minipage}}{ra}

\nextlevel[6]

\mess{\parbox{4.5cm}{start number generation \\ for C with A, B\\}}{ra}{rb}

\nextlevel


\referencestart{r}{robust key-generation protocol}{ra}{rb}
\nextlevel[2]
\gate[r][b]{out}{rleft}
\mess{\parbox{4cm}{node certificates \\ signed by A and B\\}}{rleft}{client}
\nextlevel[1]
\referenceend{r}
\end{msc}
\caption{Node's join protocol}
\label{fig:node_join_prot}
\end{figure}

\paragraph{Certificate refresh} Once a certificate has been generated it is
valid only for some time. Every node that has a valid certificate that has not
been revoked may request a new certificate for the same (public key, dht key)
pair. To do this it contacts the registrar responsible for given certificate,
solves a challenge, and then sends a request for certificate update. In this
request it attaches the certificate in question. As a result the registrar sends
an updated certificate if it is still valid.

Certificate refresh is a necessary part of the protocol, since without it each
node would have to join the network again upon its expiration. It unnecessarily
induces churn and provides a vulnerability for an eclipse attack. The eclipse
attack vulnerability stems from the fact that in Kademlia it is hard to flush
out an old, active node from the routing table. This behaviour is used in KAD to
prevent an attacker, who might even have large number of IDs, to overwrite data
that sits in the table by spamming the node in question hoping to replaced the
older honest. If we force every node to reentry upon expiration date then the
natural Kademlia defense is rendered void.

\subsection{Certificate revocation system}

One of the advantages of a centralized certificate issuers is that they can
revoke certificates. Typical distributed scheme only offers a local protection:
a node that detects malicious behaviour simply discards the offender from its
routing table, the malicious node may still contact other oblivious nodes. With
revocation it is possible to eliminate offenders globally, drastically
increasing a cost of an attack.

A certificate revocation looks the same as a certificate, that is it is a
tuple:\\
(\texttt{NODE\_PUB\_KEY},~\texttt{NODE\_DHT\_KEY},~\texttt{EXPIRATION\_DATETIME})
signed by a registrar. This tuple means that certificate for given pair is no
longer valid and it should be removed from a routing table and its messages
should be discarded. Each registrar maintains its own revocation list and each
DHT node should periodically synchronize this list with its own copy.
Certificate revocations are destroyed after the certificate they revoke is no
longer valid. That's what is meant by the expiration date.

TODO
[Wersje: Pobieramy bezposrednio lub też plotkujemy]
[Wersje: Może jakiś merkle tree, bloom filter]
[Wersje: Challenge lub bez challenge'u

\subsection{SybilControl - Limiting number of Sybil nodes with computational
puzzles}
\subsubsection{Goals}
  Verifiable random key generation in Kademlia is a defense against eclipse
  style attacks, which in Kademlia are much harder to launch than in other
  DHTs, such as Chord, due to nonstrict routing tables and redundant, iterative
  routing algorithm. Unless attacker has access to a large number of nodes it is
  difficult to launch an successful eclipse attack \cite{mac09}. Therefore for
  Ghoul to be secure a protection scheme against a Sybil attack is necessary.
  Although the scope of such an attack will be limited by the centralized
  authority, thanks to the use of computation puzzles, only the rate of
  entry is limited. It's still possible to accumulate Sybil nodes over time.

  The centralized authority allows for implementation of various anti-Sybil
  check schemes, but such a scheme would increase responsibilities of those
  nodes which we might want to keep as simple as possible. So in order to
  provide a defense against Sybil attack Ghoul incorporates SybilControl into
  its mechanisms.

\subsubsection{SybilControl mechanism}
  SybilControl is fully described in \cite{li12}. Here I will describe the core
  mechanism as it is used in Ghoul. 

  To limit the number of Sybil nodes SybilControl requires that nodes
  perdiodically generate a cryptographic puzzle and solve it. To verify that
  this puzzle is generated honestly it includes similarly generated puzzles
  propagated from its neighbors. Let's call the puzzle string for node $A$ as
  $C_{A-new}$. Assuming $A$ has received puzzles $C_{B_i}$ from its neighbors
  $B_{i}$, then $C_{A-new}$ is:

  \begin{eqnarray*}
      R_{A-new} &=& B_1||C_{B_1}||\ldots||B_n||C_{B_n}||r_A||C_{A-old}\\
    C_{A-new} &=& H\left(R_{A-new}\right)
  \end{eqnarray*}

  $r_A$ is a random string generated by $A$. $C_{A-old}$ is the previous puzzle
  generated by $A$. $H$ is a one-way function such as \texttt{SHA-2}. This is to
  ensure that $r_A$ is not specially prepared to make the puzzle solving easy.

  The solution to the puzzle is such a string $S$ that:

  \[ h = H\left(A||C_A||S\right)\]

  has at least $p$ last bits equal to zero.

  The entire puzzle state $P$ consists of: the solution $S_P$, the challenge
  $C_P$ and the record state $R_P$. Generated puzzle states are kept for some
  globally defined time for verification purposes.

  \paragraph{Neighbor node verification}
  To verify that a neighbor node $B$ of $A$ has done its proof-of-work it is
  asked to send its latest puzzle state $P_B$. Then the asking node checks
  whether this is a valid, solved puzzle state and that it includes one of
  recent puzzles generated by $A$. Successful check means that $B$ has done some
  work recently and may be treated as an honest node.

  \paragraph{Non-neighbor node verification}
  To verify that a non-neighbor node has solved its puzzle in the recent past we
  need to check that our recent challenge has influenced its puzzle. To do that
  we find a path between us and the non-verified node. We query nodes in the
  path for their puzzle state history. The node verification is then equivalent
  to finding out in these puzzle state histories all puzzles that have
  influenced the puzzle of the node under verification. The node is verified iff
  a puzzle that we have recently produced is among them.

\subsubsection{SybilControl vulnerabilities}
  Authors of the SybilControl paper did not consider some pernicious
  vulnerabilities, which may break the protocol. Here I will describe what they
  are and how does Ghoul deal with them.

  First off the protocol loosely defines what constitutes a neighbor. An
  uncareful implementation of SybilControl in which every cryptographic puzzle
  propagation is included in the generation of the next puzzle may increase the
  size of the puzzle size considerably. This kind of behavior may be used to
  slow down the DHT by nodes which gratuitously send challenge updates to all
  nodes in the DHT. Li et al. do not take this into consideration. This can
  be prevented by including only challenges received from verified nodes, such
  as nodes in the routing table, and additionally limiting the number of
  included challenges to those that have been received in the last $2p$ seconds
  from the $i$ closest nodes. Where $p$ and $i$ are globally defined constants.

  Secondly non-neighbor node verification requires collaboration from
  intermediate nodes, failing nodes may cause the check to fail and malicious
  nodes may even try to incriminate an honest node. A malicious node may
  correctly participate in the DHT, but when it is an intermediate node in
  SybilControl check it might drop the query. Although Kademlia uses redundant
  routing, such an attack may cause a snowballing effect over time. To prevent
  that behaviour the direct and non-direct check need to be indistinguishable.
  If those checks are indistinguishable an attacker who drops SybilControl
  queries causes other nodes to consider him malicious and remove him from
  routing tables.

  To make queries indistinguishable we define only one SybilControl query
  message: \texttt{SC\_QUERY}, which is parametrized by a searched key. Its
  response should be a collection of nodes closest to given key and the history
  of puzzle states of the recipient. Direct verification simply looks at the
  latest puzzle in the history and discards all the other information.
  Non-direct check uses the found key for typical find node operation and also
  the history for SybilControl verification. In fact in this scheme there's no
  need for distinguishing direct and non-direct verification from the point of
  view of the verifier.

\subsubsection{SybilControl in Ghoul}
  SybilControl requires additional consideration as to how it integrates with
  Kademlia.

  The protocol described in SybilControl has only local effects, that is a node
  that does not have an up-to-date puzzle will just not be included into the
  routing table. Since Ghoul uses a certification system with revocation it is
  possible for nodes to complain about others to registrars. If registrars find
  that given node is malicious or Sybil they may globally revoke its
  certificate.

  The size of the SybilControl query also needs to be considered. Usually a
  Kademlia implementation uses UDP protocol for message sending. This means that
  the maximal size of a single message is 64KB. This gives us a bound on the
  SybilControl query response. Assuming likely value of keeping 10 last puzzle
  states in history this means we have 6.4KB for one puzzle state record.
  Kademlia key and challenge ($B_i || C_{B_i}$) are of size $160 + 16$ or $160
  + 32$ bytes, that is around 200 bytes. Which forces us to consider only 32
  neighbor challenges when building a our puzzle. Perhaps even a little bit
  less to accomodate other metadata. The \texttt{SC\_QUERY} is the only message
  that has potential to be too large if unconsidered.

\section{Evaluation}
  This section concludes the specification of Ghoul. Here I will evaluate its
  strengths and weaknesses.
  
  \subsection{Security}
  The core advantage of this design is that it secures the DHT from Sybil and
  eclipse attacks while at the same time it does not take any additional
  assumptions about available resources, apart from computing power. It does not
  assume anything about security properties of IP address or other network
  characteristics or require a Social network, or establishment of symmetric key
  architecture.
  
  This means that setting up Ghoul does not require any more work than setting
  up a bare Kademlia implementation, sometimes even less since some protection
  schemes stop working for users behind NAT.

  Also, because we keep the completely abstract nature of identification, that
  is a pair of DHT key and public key, it is perfectly possible to augment this
  scheme with other security protocols. Application programmer may augment the
  scheme anonymization, using transport-level protocols like Tor or DHT-level
  solution like Octopus~\cite{wan12b}.

  Ghoul ensures that keys are generated fairly and that every node performs
  periodic proof-of-work, which limits the size of a Sybil attack. This coupled
  with natural redundancy of Kademlia protocol also make launching an eclipse
  attack much harder.

  Ghoul, however is not invulnerable and has a few weaknesses:

  \begin{description}
    \item{\textbf{anonymization}} Lack of anonymization gives a snooping
      attacker a possibility to acquire information about node's behaviour and
      use it to augment his attack. For example if an attacker can predict
      whether node verification in the SybilControl scheme is direct or not then
      this whole scheme is rendered void.
    \item{\textbf{denial of service}} Additional security mechanisms increase
      amount of work a node can and needs to perform. If nodes do not limit this
      a crafty attacker may congest a node with specially defined behaviour. One
      pernicious example of this class of attack is attack on the certificate
      revocation scheme. An attacker might introduce a large number of correctly
      behaving nodes in the system, who after some time start behaving
      maliciously, which is detected by Ghoul and their certificate's are
      revoked. On first sight this is a desired behaviour, but if the number of
      such nodes is very large then the revocation list become large as well.
      Since each DHT node will try to synchronize this list it may generate
      traffic large enough to congest it.
  \end{description}

  \subsection{Performance}

  Ghoul focuses on changing node join and neighbour addition protocol and as
  such does not change anything else. Especially a typical use of Kademlia for
  finding nodes or data does incur any performance penalty.

  Node join protocol changes an instantaneous operation into a small distributed
  protocol with some proof-of-work. Since this happens only once its cost is
  negligible. From the point of view the central authority the node join
  protocol requires it to only be able to generate and save nonces and perform
  the distributed key generation algorithm. Since node's join happens only once
  in the existance and those operations are lightweight then it means that the
  central authority can be a simple machine and should not be a performance
  bottleneck.

  The biggest performance overhead happens during neighbour addition when
  verification is performed. The verification message complexity is on the order
  of $O(\log n)$ and requires sending larger messages. This exacerbates effects
  of churn and the network will take longer time to adapt to topology changes.
  A more detailed analysis of SybilControl's impact on DHT behaviour can be
  found in \cite{li12}..

  Since Ghoul uses computational resources for proof-of-work verification
  therefore this parameter requires careful tuning. Application designer needs
  to consider the weakest node that should be able to join the DHT and also be
  aware that a Sybil attacker may create as many identities as is the factor
  of his computing power compared to the weakest node. Therefore tests with
  small hardness may prove to be ineffective in blocking an attack. On the other
  hand a weak node may still use Ghoul without performing any additional work,
  so we can only consider more powerful ones for creating the DHT.

  \subsection{Other}

  The centralized authority leaves a sour taste to anyone looking for a
  distributed solution. Although the main reason for its inclusion is lack of
  an effective and distributed solution for random number generation, I would
  like to argue that using centralized authority is not really a problem and
  provides distinct advantages.

  First of a


  [About the benefits of centralized authority]
